<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<title>CSCI 241 - Homework 8</title>
<link rev="made" href="mailto:rhoyle@cs.oberlin.edu">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
<link rel="stylesheet" type="text/css" href="homework.css">
</head>


<body>

<h1>CSCI 241 - Homework 8:<br>Huffman's Algorithm</h1>
<p>
    <em>Due by 11:59.59pm, Tuesday, May 24th</em>
</p>

<h2>Introduction</h2>
<p>
    For this assignment, you will be creating two programs (<tt>encode</tt> and
    <tt>decode</tt>) that will be performing the calculations needed for simple
    file compression.  (For small files, it'll might make things a little
    bigger.)
</p>

<h3>Things to note</h3>
<ul class="padded">
    <li>The repository URL for this assignment is <a href="https://classroom.github.com/a/CgOFmH6v">https://classroom.github.com/a/CgOFmH6v</a></li>

    <li>This project is trickier than most. 
       <em>Get started on it early!</em> 
    </li>
<!-- 
   <li>I'm giving you more than a week for this project.  
       <em>Get started on it early</em>
       and spend time working on it before Thanksgiving week.</li> 
-->

    <!-- 
    <li>You may share encoded files between groups, but I ask that you send me a
        copy so that I can make it available to all students.</li>
    -->
</ul>

<!-- 
<hr>
<h2>Updates</h2>
<ul>
    <li>The inevitable updates will be listed here.</li>
</ul>
-->

<hr>
<h2>Program behavior</h2>
<p>
    Your <tt>encode</tt> program should read a text file specified on the
    command line and write a Huffman encoded version of that file to the
    specified output file.
    Similarly, the <tt>decode</tt> program will read a file generated by encode
    and write a decoded version of that file to a specified output file.
</p>

<p>
    If no output file is specified, write to <tt>stdout</tt>.
</p>

<pre class="boxed">
% ./encode book.txt   book.huf      # encodes book.txt and writes it to
                                    # book.huf

% ./encode book.txt > book.huf      # encodes book.txt and writes it to
                                    # stdout (redirected to book.huf)

% ./decode book.huf   book.txt.2    # decodes the file, writing to book.txt.2

% diff -q book.txt book.txt.2       # check to see if files are the same
                                    # should print nothing if they are
</pre>

<h3>Getting started</h3>
<p>
    You will likely need to divide your code into three different parts, and
    therefore should be stored in 3 different files:
</p>
<ul>
    <li>Functions needed by the encode program</li>
    <li>Functions needed by the decode program</li>
    <li>Functions used by both programs</li>
</ul>

<p>
    Now, it is possible to have only a single program that can do both encoding
    and decoding based on the filename, but to handle that, you'd need to check
    the value of <tt>argv[0]</tt> and determine which function to perform.
    It's probably easier to just make 2 separate programs.
</p>
<p>
    Recall that you can make an object file by using the "<tt>-c</tt>" flag when
    compiling.  Then you can link the various object files together to make
    actual programs.
</p>

<h2>Program Design</h2>

<h3>Encoding</h3>
<p>
In order to encode a file, you will first need to construct a Huffman tree based
on the frequency of letters in the file.  Your first step should be to read the
file from start to end and calculate either absolute or relative frequency of
all the characters encountered.  You should include the frequency of EOF
(which should always be 1) and we will store that at the beginning of our 
list of nodes (logical index of -1).
</p>

<p>
    You will then need to create a sorted list of nodes based on ascending
    frequency.  To do this, I recommend that you use an insertion sort on a
    linked list.  Insert new nodes starting with the index value of -1 and going
    up to index value of 255.  Insert <em>before</em> items of equal value.
    Skip nodes with a frequency count of 0.
</p>

<p>
    Then, you will need to convert this sorted list into a Huffman tree.  While
    there are more than 2 nodes in your list, you should create a new node,
    attach the head item in the list as the left child, the second item in the
    list as the right child, update the frequency count for this new node, and
    insert it into your linked list.  Be sure you've removed the two nodes that
    are now children before re-inserting.
</p>

<p>
    Now traverse the tree keeping track of the string needed to reach that node
    based on using a character '0' for a left branch and '1' for a right branch.
    When you reach a leaf node, you will know what string is to be used to
    represent that character.
</p>

<!-- 
<p>
    Output the frequency table and character string information to the file as
    described below.  Output a blank line at the end of this table.
</p>
-->

<p>
    Now re-read the input file from the beginning and for each letter
    encountered, print the bit string that corresponds to that character.
    <em>Be sure to output the string corresponding to the EOF notice too</em>
    and stop after you do so.
</p>

<h3>File Format</h3>
<p>
  The files to be <u>encoded</u> can be treated as simple 8-bit character files
  (but use CHAR_BIT instead of 8).
  What I mean by this is that if you call <tt>fgetc()</tt> you will get
  a character until you reach the end, at which point you will have EOF returned 
  (which we'll treat as if it has a character value of -1 -- which it should).
  By treating these files as byte-oriented rather than
  printable ASCII, you should be able to encode both text and binary files.
</p>
<!-- 
<p>
  However, the Huffman encoded output files will be a bit different.  The format
  of these files is as follows:
  <ol class="padded">
    <li>Character frequency and Huffman encoded strings</li>
    <li>A blank line</li>
    <li>A sequence of '0' and '1' characters representing the Huffman encoded
    output stream.  Note that these are characters, not individual bits.</li>
    <li>A carriage return (purely for aesthetics)</li>
  </ol>
</p>
-->
<p>
    The Huffman encoded output files will be a bit different.  You need to
    include the binary trie representing the Huffman prefix codes.
    To do this, you will do a pre-order traversal of the trie using a 0-bit to
    indicate that it is an internal node and therefore has left and right
    children, or a 1-bit to indicate that it is a leaf node.  Immediately
    following the 1-bit you will write the CHAR_BIT bits from most to least
    significant that make up the value of the character at that location in the
    tree.
</p>

<p>
    Immediately following the pre-order traversal of the tree, you will write an
    initial bit-string representing EOF.  (You will later use that to find the
    leaf that represents EOF instead of 255 and correct the value there.)
</p>

<p>
    After the table, you should output the individual bits that are needed to
    represent the input file.  You'll have to buffer the bits until you get
    CHAR_BIT of them and then output it.  (The most significant bit is the first
    bit, and then they progress downward.)  
    Hint, you might want to look at what you wrote for <a
    href="hw04.html">homework 4</a> encode_bits and decode_bits.
</p>
<p>
    Pad out the last incomplete character
    in the file with 0 bits.  If you write (CHAR_BIT-1) 0-bits out then it will
    flush any remaining bits without creating a new character.
</p>

<!-- 
<p>
    Here is the info from one of the sample files encoding the string <tt>"a\n"</tt>:
</p>
<pre class="boxed">
char   count bitstring
----   ----- ---------
 -1        1 0
 10        1 11
 97        1 10

10110
</pre>
-->

<hr>
<h3>Decoding</h3>
<p>
    To decode the file, you should first open the file specified on the command
    line. You then can read in the pre-order traversal of the tree, assembling
    it as you go.  A 0-bit indicates an internal node which has both a left and
    right child.  A 1-bit indicates it is a leaf and the next CHAR_BIT bits
    represent the value at that node from MSB to LSB.
    (I found a recursive function to work nicely for this.)
</p>

<p>
    Now you need to fix the value of EOF in the tree.  Switch over to a bitwise
    read/tree traversal routing where 0 indicates to go left and 1 indicates to
    go right.  Once you hit the first leaf, you now have the location for the
    actual EOF marker and you should update the value there accordingly.
</p>

<p>
    Now you continue with a bitwise read/tree traversal routine and use those
    to determine if you should go left on 0 or right on 1 in the tree.  Once you
    reach a leaf, you should be at a letter.  Print it and move back to the
    root.  When you reach the EOF marker you should stop reading/printing
    and close both files.  Nothing is printed for the EOF marker.
</p>

<!-- 
<p>
    To decode the file, you should first open the file specified on the command
    line.  Read in a line at a time processing each line for a frequency count
    and/or a string to match against.  Once you encounter a blank line, you know
    you have read the entire table in.  Recall that strings returned by fgets()
    include the newline at the end of the line.
</p>
<p>
    If you need to, you can create the Huffman tree from the frequency counts,
    or you can use the pre-computed strings from the header as well.
</p>

<p>
Now, switch from line oriented input, to character oriented.  Read in each '0'
and '1' and whenever you have matched a Huffman string, you should output that
character to the output file.  Once you have read the EOF character, you should
stop reading and printing, and close both files. 
</p>
-->
<p>
<b>NOTE:</b>
<em>
You should not print out anything when you reach the EOF marker,
and you should never reach the actual end of the encoded file.
</em>
</p>

<h3>Sample run -- with internal state</h3>
<br>
<pre class="boxed">
<b>INPUT:</b>
cheese

<b>Frequency Counts:</b>
-1     EOF     1
10     \n      1
99     c       1
101    e       3
104    h       1
115    s       1

<b>Linked List (initial):</b>
s(1) -> h(1) -> c(1) -> \n(1) -> EOF(1) -> e(3)

<b>First pass:</b>
c(1) -> \n(1) -> EOF(1) -> (2) -> e(3)
                          /   \
                      s(1)     h(1)    

<b>Second pass:</b>
EOF(1) -> (2)   -->   (2) -> e(3)
         /   \       /   \
      c(1)  \n(1)  s(1)   h(1)    

<!-- TODO: HERE -->
<b>Third pass:</b>
   (2)  ------>  (3)  ---> e(3)
  /   \         /   \
s(1)   h(1) EOF(1)  (2)
                   /   \
                 c(1) \n(1)

<b>Fourth pass:</b>
e(3) -----------> (5)
               /       \
           (2)           (3)
          /   \         /   \
        s(1)   h(1) EOF(1)  (2)
                           /   \
                         c(1) \n(1)

<b>Fifth (and final) pass:</b>
         (8)
    /           \
e(3)              (5)
               /       \
           (2)           (3)
          /   \         /   \
        s(1)   h(1) EOF(1)  (2)
                           /   \
                         c(1) \n(1)

<b>Internal data:</b> (including padding)
char       count bitstring
----       ----- ---------
 -1  EOF       1 110
 10  \n        1 1111
 99  c         1 1110
101  e         3 0
104  h         1 101
115  s         1 100

<b>Tree:</b> (with added spaces for clarity)
0 1 01100101 0 0 1 01110011 1 01101000 0 1 11111111 0 1 01100011 1 00001010

<b>EOF:</b> 110

<b>Remainder of file:</b> (spaces added, includes EOF)
1110 101 0 0 100 0 1111 110

<b>Remainder is padding to make it a full char:</b>
000000
</pre>

<p>
You can also use some Unix tools to examine your output files:
</p>

<pre class="boxed">
<b>File passed through xxd:</b>
0000000: <span class="term">594b 9da1 ff58 e15b a91f 80</span>              YK...X.[...

<b>File passed through xxd -b: (bits)</b>
0000000: <span class="term">01011001 01001011 10011101 10100001 11111111 01011000</span>  YK...X
0000006: <span class="term">11100001 01011011 10101001 00011111 10000000 </span>          .[...
</pre>

<hr>
<h3>Design Ideas</h3>
<p>
You'll need to be dynamically creating nodes, so <tt>malloc()</tt> and
<tt>free()</tt> are your friends.   Be sure to free() all the allocated data
once you are done with it, and <tt>fclose()</tt> all files you opened.  Valgrind
should report that there were no memory leaks.
</p>

<p>
You might want to create a node struct that can be used in both a linked list
and a tree simultaneously.  So, you'll want to have both "left" and "right"
pointers as well as a "next" pointer.
</p>

<p>
    You can create an array that has 256-buckets for your counts and hard-code
    the fact that your EOF node has a frequency of 1.  This is the most
    straightforward approach.
</p>

<p>
    If you want, you can create an array that has a valid position at index -1
    by dynamically allocating an array and then setting a pointer to the address
    of the first item in the array.  If you then use the pointer in an array
    context, you can go from index -1 to N-2.  
    Just remember that you need to <code>free()</code> from the actual start of the array.
</p>

<p>
    You should print a message and exit if you attempt to malloc something and
    it fails.  Rather than just cutting and pasting this throughout your code,
    why not write a function that does the malloc(), the check for failure, and
    perhaps some initialization.
</p>

<hr>
<p>
    There is also sample binaries for you to play with in
    <tt>~rhoyle/pub/cs241/hw06/</tt>
</p>

<hr>
<h2>handin</h2>

<h3>README</h3>
<p>
    Create a file called <tt>README</tt> that contains
</p>
<ol>
    <li>Your name and partner's name (if any)</li>
    <li>A description of the programs</li>
    <li>A listing of the files with a short one line description of the contents</li>

    <li>Any known bugs or incomplete functions</li>
    <li>An estimate of the amount of time you spent completing this assignment</li>
    <li>Any interesting design decisions you'd like to share</li>

    <LI> Describe any unresolved warnings that are generated by valgrind and
            what you believe them to be caused by.</LI>

<!-- 
    <li>If you did the extra credit, describe the technique you used and the
        approximate space savings.</li>
-->

</ol>

<h3>man pages</h3>
<p>
    Also, create <tt>encode(1)</tt> and <tt>decode(1)</tt> man pages.  See <a
    href="hw03-strings.html">HW
    3</a> for a refresher.
    These should be named <tt>encode.1</tt> and <tt>decode.1</tt> since these are user commands.
</p>

<p>
    Now you should <tt>make clean</tt> to get rid of your executables/object
    files and handin your folder containing your source files, Makefile, and
    README. 
</p>


<h2>Extra Credit</h2>

In this compression algorithm, we are looking at single characters to create our encoding tree.  For extra credit, experiment with 2-3 character sequences, and see if they create a better compression tree.

<h2>Grading</h2>
<p>
    Here is what I am looking for in this assignment:
</p>
<ul class="padded">
    <li>A working Makefile with your program, all, and clean as targets</li>

    <li>A program that will encode files using Huffman's algorithm as described
        above.</li>

    <li>A program that will decode files encoded with Huffman's algorithm as
    described above.</li>

    <li>An internal linked-list representation using structs</li>

    <li>Output matching the sample program</li>

    <li>Appropriately modular code</li>
    
    <li>Good comments</li>

    <li>Runs under valgrind with no errors or warnings</li>

    <li>Man pages for each program</li>

    <li>A README with the information requested above.  The listing of known
    bugs is important.</li>

</ul>

<!---
<h2>Grading Rubric</h2>

<pre>
  encode:[/20]
  decode: [/20]
  man/Makefile/README:[/5]
  valgrind: [/5]

  TOTAL:  [/50]
</pre>
-->
<hr>
<address>Last Modified: April 19, 2017 - <a href="mailto:rhoyle@cs.oberlin.edu">Roberto Hoyle</a> from material created by Ben Kuperman</address>
<!-- Created: April 13, 2006 -->

</body>
</html>

<!-- vim: set fdm=marker tw=80: -->
